import { EventEmitter, Component, ElementRef, ChangeDetectorRef, Renderer2, Input, ViewChild, Directive, ViewContainerRef, ComponentFactoryResolver, ApplicationRef, Injector, Output, HostListener, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["popoverDiv"];
const _c1 = function (a0, a1, a2, a3) { return { "sm": a0, "md-sm": a1, "md": a2, "lg": a3 }; };
const _c2 = ["*"];
class PopoverPlacement {
}
PopoverPlacement.Bottom = 'bottom';
PopoverPlacement.BottomLeft = 'bottom-left';
PopoverPlacement.BottomRight = 'bottom-right';
PopoverPlacement.Left = 'left';
PopoverPlacement.Right = 'right';
PopoverPlacement.Top = 'top';
PopoverPlacement.TopLeft = 'top-left';
PopoverPlacement.TopRight = 'top-right';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverContentComponent {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    /**
     * @param {?} element
     * @param {?} cdr
     * @param {?} renderer
     */
    constructor(element, cdr, renderer) {
        this.element = element;
        this.cdr = cdr;
        this.renderer = renderer;
        this.placement = PopoverPlacement.Top;
        this.animation = true;
        this.closeOnClickOutside = false;
        this.closeOnMouseOutside = false;
        this.size = 'small';
        this.onCloseFromOutside = new EventEmitter();
        this.top = -10000;
        this.left = -10000;
        this.isIn = false;
        this.displayType = 'none';
        this.opacity = 0;
        this.transitionEnabled = false;
        this.windowWidth = window.innerWidth;
        this.windowHeight = window.innerHeight;
        // -------------------------------------------------------------------------
        // Anonymous
        // -------------------------------------------------------------------------
        /**
         * Closes dropdown if user clicks outside of this directive.
         */
        this.onDocumentMouseDown = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const element = this.element.nativeElement;
            if (!element || !this.popover) {
                return;
            }
            if (element.contains(event.target) || this.popover.getElement().contains(event.target)) {
                return;
            }
            this.onCloseFromOutside.emit(undefined);
        });
    }
    // -------------------------------------------------------------------------
    // Lifecycle callbacks
    // -------------------------------------------------------------------------
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.closeOnClickOutside) {
            this.listenClickFunc = this.renderer.listen('document', 'mousedown', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.onDocumentMouseDown(event)));
        }
        if (this.closeOnMouseOutside) {
            this.listenMouseFunc = this.renderer.listen('document', 'mouseover', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.onDocumentMouseDown(event)));
        }
        // Always close on mobile touch event outside.
        this.listenTouchFunc = this.renderer.listen('document', 'touchstart', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.onDocumentMouseDown(event)));
        this.show();
        this.cdr.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.closeOnClickOutside && this.listenClickFunc) {
            this.listenClickFunc();
        }
        if (this.closeOnMouseOutside && this.listenMouseFunc) {
            this.listenMouseFunc();
        }
        if (!!this.listenTouchFunc) {
            this.listenTouchFunc();
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * @return {?}
     */
    updatePosition() {
        // if visible, reposition
        if (this.opacity) {
            /** @type {?} */
            const p = this.positionElements(this.popover.getElement(), this.popoverDiv.nativeElement, this.placement, this.appendToBody);
            this.top = p.top;
            this.left = p.left;
        }
    }
    /**
     * @return {?}
     */
    show() {
        if (!this.popover || !this.popover.getElement()) {
            return;
        }
        /** @type {?} */
        const p = this.positionElements(this.popover.getElement(), this.popoverDiv.nativeElement, this.placement, this.appendToBody);
        this.displayType = 'block';
        this.top = p.top;
        this.left = p.left;
        this.isIn = true;
        this.transitionEnabled = true;
        this.opacity = 1;
    }
    /**
     * @return {?}
     */
    hide() {
        this.top = -10000;
        this.left = -10000;
        this.isIn = true;
        this.popover.hide();
    }
    /**
     * @return {?}
     */
    hideFromPopover() {
        this.top = -10000;
        this.left = -10000;
        this.isIn = true;
        this.transitionEnabled = false;
        this.opacity = 0;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * @protected
     * @param {?} hostEl
     * @param {?} targetEl
     * @param {?} positionStr
     * @param {?=} appendToBody
     * @return {?}
     */
    positionElements(hostEl, targetEl, positionStr, appendToBody = false) {
        /** @type {?} */
        const positionStrParts = ((/** @type {?} */ (positionStr))).split(' ');
        /** @type {?} */
        let pos0 = positionStrParts[0];
        /** @type {?} */
        const pos1 = positionStrParts[1] || 'center';
        /** @type {?} */
        const hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
        /** @type {?} */
        const targetElWidth = targetEl.offsetWidth;
        /** @type {?} */
        const targetElHeight = targetEl.offsetHeight;
        this.effectivePlacement = pos0 = this.getEffectivePlacement(pos0, hostEl, targetEl);
        /** @type {?} */
        const shiftWidth = {
            center: (/**
             * @return {?}
             */
            function () {
                return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
            }),
            left: (/**
             * @return {?}
             */
            function () {
                return hostElPos.left;
            }),
            right: (/**
             * @return {?}
             */
            function () {
                return hostElPos.left + hostElPos.width;
            }),
            topOrBottomRight: (/**
             * @return {?}
             */
            function () {
                return hostElPos.left + hostElPos.width / 2;
            }),
            topOrBottomLeft: (/**
             * @return {?}
             */
            function () {
                return hostElPos.left - targetElWidth + hostElPos.width / 2;
            })
        };
        /** @type {?} */
        const shiftHeight = {
            center: (/**
             * @return {?}
             */
            function () {
                return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
            }),
            top: (/**
             * @return {?}
             */
            function () {
                return hostElPos.top;
            }),
            bottom: (/**
             * @return {?}
             */
            function () {
                return hostElPos.top + hostElPos.height;
            })
        };
        /** @type {?} */
        let targetElPos;
        switch (pos0) {
            case PopoverPlacement.Right:
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: shiftWidth[pos0]()
                };
                break;
            case PopoverPlacement.Left:
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: hostElPos.left - targetElWidth
                };
                break;
            case PopoverPlacement.Bottom:
                targetElPos = {
                    top: shiftHeight[pos0](),
                    left: shiftWidth[pos1]()
                };
                break;
            case PopoverPlacement.TopLeft:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth['topOrBottomLeft']()
                };
                break;
            case PopoverPlacement.TopRight:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth['topOrBottomRight']()
                };
                break;
            case PopoverPlacement.BottomLeft:
                targetElPos = {
                    top: shiftHeight[PopoverPlacement.Bottom](),
                    left: shiftWidth['topOrBottomLeft']()
                };
                break;
            case PopoverPlacement.BottomRight:
                targetElPos = {
                    top: shiftHeight[PopoverPlacement.Bottom](),
                    left: shiftWidth['topOrBottomRight']()
                };
                break;
            default:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth[pos1]()
                };
                break;
        }
        return targetElPos;
    }
    /**
     * @protected
     * @param {?} nativeEl
     * @return {?}
     */
    position(nativeEl) {
        /** @type {?} */
        let offsetParentBCR = { top: 0, left: 0 };
        /** @type {?} */
        const elBCR = this.offset(nativeEl);
        /** @type {?} */
        const offsetParentEl = this.parentOffsetEl(nativeEl);
        if (offsetParentEl !== window.document) {
            offsetParentBCR = this.offset(offsetParentEl);
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }
        /** @type {?} */
        const boundingClientRect = nativeEl.getBoundingClientRect();
        return {
            width: boundingClientRect.width || nativeEl.offsetWidth,
            height: boundingClientRect.height || nativeEl.offsetHeight,
            top: elBCR.top - offsetParentBCR.top,
            left: elBCR.left - offsetParentBCR.left
        };
    }
    /**
     * @protected
     * @param {?} nativeEl
     * @return {?}
     */
    offset(nativeEl) {
        /** @type {?} */
        const boundingClientRect = nativeEl.getBoundingClientRect();
        return {
            width: boundingClientRect.width || nativeEl.offsetWidth,
            height: boundingClientRect.height || nativeEl.offsetHeight,
            top: boundingClientRect.top + (window.pageYOffset || window.document.documentElement.scrollTop),
            left: boundingClientRect.left + (window.pageXOffset || window.document.documentElement.scrollLeft)
        };
    }
    /**
     * @protected
     * @param {?} nativeEl
     * @param {?} cssProp
     * @return {?}
     */
    getStyle(nativeEl, cssProp) {
        if (((/** @type {?} */ (nativeEl))).currentStyle) { // IE
            return ((/** @type {?} */ (nativeEl))).currentStyle[cssProp];
        }
        if (window.getComputedStyle) {
            return ((/** @type {?} */ (window.getComputedStyle)))(nativeEl)[cssProp];
        }
        // finally try and get inline style
        return ((/** @type {?} */ (nativeEl.style)))[cssProp];
    }
    /**
     * @protected
     * @param {?} nativeEl
     * @return {?}
     */
    isStaticPositioned(nativeEl) {
        return (this.getStyle(nativeEl, 'position') || 'static') === 'static';
    }
    /**
     * @protected
     * @param {?} nativeEl
     * @return {?}
     */
    parentOffsetEl(nativeEl) {
        /** @type {?} */
        let offsetParent = nativeEl.offsetParent || window.document;
        while (offsetParent && offsetParent !== window.document && this.isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || window.document;
    }
    // Check for overflow of the viewport and reflect the position if necessary.
    /**
     * @protected
     * @param {?} placement
     * @param {?} hostElement
     * @param {?} targetElement
     * @return {?}
     */
    getEffectivePlacement(placement, hostElement, targetElement) {
        /** @type {?} */
        const hostElBoundingRect = hostElement.getBoundingClientRect();
        /** @type {?} */
        const desiredPlacement = placement || PopoverPlacement.Top;
        // Reflect appropriately if overflow.
        if (desiredPlacement === PopoverPlacement.Top) {
            /** @type {?} */
            const isTopOverflow = hostElBoundingRect.top - targetElement.offsetHeight < 0;
            /** @type {?} */
            const isRightOverflow = hostElBoundingRect.left + hostElBoundingRect.width / 2 + targetElement.offsetWidth / 2 > this.windowWidth;
            /** @type {?} */
            const isLeftOverflow = hostElBoundingRect.left + hostElBoundingRect.width / 2 - targetElement.offsetWidth / 2 < 0;
            if (isTopOverflow) {
                return PopoverPlacement.Bottom;
            }
            else if (isRightOverflow) {
                return PopoverPlacement.TopLeft;
            }
            else if (isLeftOverflow) {
                return PopoverPlacement.TopRight;
            }
        }
        if (desiredPlacement === PopoverPlacement.Bottom) {
            /** @type {?} */
            const isRightOverflow = hostElBoundingRect.left + hostElBoundingRect.width / 2 + targetElement.offsetWidth / 2 > this.windowWidth;
            /** @type {?} */
            const isLeftOverflow = hostElBoundingRect.left + hostElBoundingRect.width / 2 - targetElement.offsetWidth / 2 < 0;
            /** @type {?} */
            const isBottomOverflow = hostElBoundingRect.bottom + targetElement.offsetHeight > this.windowHeight;
            if (isBottomOverflow) {
                return PopoverPlacement.Top;
            }
            else if (isRightOverflow) {
                return PopoverPlacement.BottomLeft;
            }
            else if (isLeftOverflow) {
                return PopoverPlacement.BottomRight;
            }
        }
        if (desiredPlacement === PopoverPlacement.Left) {
            /** @type {?} */
            const isTopOverflow = hostElBoundingRect.top + hostElBoundingRect.height / 2 - targetElement.offsetHeight / 2 < 0;
            /** @type {?} */
            const isLeftOverflow = hostElBoundingRect.left - targetElement.offsetWidth < 0;
            /** @type {?} */
            const isBottomOverflow = hostElBoundingRect.top + hostElBoundingRect.height / 2 + targetElement.offsetHeight / 2 > this.windowHeight;
            if (isLeftOverflow) {
                return PopoverPlacement.Right;
            }
            else if (isTopOverflow) {
                return PopoverPlacement.BottomLeft;
            }
            else if (isBottomOverflow) {
                return PopoverPlacement.TopLeft;
            }
        }
        if (desiredPlacement === PopoverPlacement.Right) {
            /** @type {?} */
            const isTopOverflow = hostElBoundingRect.top + hostElBoundingRect.height / 2 - targetElement.offsetHeight / 2 < 0;
            /** @type {?} */
            const isRightOverflow = hostElBoundingRect.right + targetElement.offsetWidth > this.windowWidth;
            /** @type {?} */
            const isBottomOverflow = hostElBoundingRect.top + hostElBoundingRect.height / 2 + targetElement.offsetHeight / 2 > this.windowHeight;
            if (isRightOverflow) {
                return PopoverPlacement.Left;
            }
            else if (isTopOverflow) {
                return PopoverPlacement.BottomRight;
            }
            else if (isBottomOverflow) {
                return PopoverPlacement.TopRight;
            }
        }
        if (desiredPlacement === PopoverPlacement.TopRight) {
            /** @type {?} */
            const isTopOverflow = hostElBoundingRect.top - targetElement.offsetHeight < 0;
            /** @type {?} */
            const isRightOverflow = hostElBoundingRect.right + targetElement.offsetWidth > this.windowWidth;
            if (isTopOverflow && isRightOverflow) {
                return PopoverPlacement.BottomLeft;
            }
            else if (isTopOverflow) {
                return PopoverPlacement.BottomRight;
            }
            else if (isRightOverflow) {
                return PopoverPlacement.TopLeft;
            }
        }
        if (desiredPlacement === PopoverPlacement.TopLeft) {
            /** @type {?} */
            const isTopOverflow = hostElBoundingRect.top - targetElement.offsetHeight < 0;
            /** @type {?} */
            const isLeftOverflow = hostElBoundingRect.left - targetElement.offsetWidth < 0;
            if (isTopOverflow && isLeftOverflow) {
                return PopoverPlacement.BottomRight;
            }
            else if (isTopOverflow) {
                return PopoverPlacement.BottomLeft;
            }
            else if (isLeftOverflow) {
                return PopoverPlacement.TopRight;
            }
        }
        if (desiredPlacement === PopoverPlacement.BottomRight) {
            /** @type {?} */
            const isBottomOverflow = hostElBoundingRect.bottom + targetElement.offsetHeight > this.windowHeight;
            /** @type {?} */
            const isRightOverflow = hostElBoundingRect.right + targetElement.offsetWidth > this.windowWidth;
            if (isBottomOverflow && isRightOverflow) {
                return PopoverPlacement.TopLeft;
            }
            else if (isBottomOverflow) {
                return PopoverPlacement.TopRight;
            }
            else if (isRightOverflow) {
                return PopoverPlacement.BottomLeft;
            }
        }
        if (desiredPlacement === PopoverPlacement.BottomLeft) {
            /** @type {?} */
            const isBottomOverflow = hostElBoundingRect.bottom + targetElement.offsetHeight > this.windowHeight;
            /** @type {?} */
            const isLeftOverflow = hostElBoundingRect.left - targetElement.offsetWidth < 0;
            if (isBottomOverflow && isLeftOverflow) {
                return PopoverPlacement.TopRight;
            }
            else if (isBottomOverflow) {
                return PopoverPlacement.TopLeft;
            }
            else if (isLeftOverflow) {
                return PopoverPlacement.BottomRight;
            }
        }
        return desiredPlacement;
    }
}
PopoverContentComponent.ɵfac = function PopoverContentComponent_Factory(t) { return new (t || PopoverContentComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
PopoverContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PopoverContentComponent, selectors: [["popover-content"]], viewQuery: function PopoverContentComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popoverDiv = _t.first);
    } }, inputs: { placement: "placement", animation: "animation", closeOnClickOutside: "closeOnClickOutside", closeOnMouseOutside: "closeOnMouseOutside", size: "size", content: "content", title: "title", parentClass: "parentClass", appendToBody: "appendToBody" }, ngContentSelectors: _c2, decls: 9, vars: 26, consts: [["role", "popover", 3, "ngClass"], ["popoverDiv", ""], [1, "virtual-area", 3, "hidden"], [1, "arrow"], [1, "popover-header", 3, "hidden"], [1, "popover-body"]], template: function PopoverContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelement(2, "div", 2);
        ɵngcc0.ɵɵelement(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵprojection(7);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate2("bs-popover-", ctx.effectivePlacement, " popover-content popover ", ctx.parentClass, "");
        ɵngcc0.ɵɵstyleProp("top", ctx.top, "px")("left", ctx.left, "px")("transition", ctx.transitionEnabled ? "0.15s opacity" : "")("opacity", ctx.opacity)("display", "block");
        ɵngcc0.ɵɵclassProp("in", ctx.isIn);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction4(21, _c1, ctx.size === "small", ctx.size === "medium-small", ctx.size === "medium", ctx.size === "large"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("hidden", !ctx.closeOnMouseOutside);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("hidden", !ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.content, " ");
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2 });
/** @nocollapse */
PopoverContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
PopoverContentComponent.propDecorators = {
    content: [{ type: Input }],
    placement: [{ type: Input }],
    title: [{ type: Input }],
    parentClass: [{ type: Input }],
    animation: [{ type: Input }],
    closeOnClickOutside: [{ type: Input }],
    closeOnMouseOutside: [{ type: Input }],
    appendToBody: [{ type: Input }],
    size: [{ type: Input }],
    popoverDiv: [{ type: ViewChild, args: ['popoverDiv',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopoverContentComponent, [{
        type: Component,
        args: [{
                selector: 'popover-content',
                template: `
    <div #popoverDiv
        class="bs-popover-{{ effectivePlacement }} popover-content popover {{ parentClass }}"
        [ngClass]="{
            'sm': size === 'small',
            'md-sm': size === 'medium-small',
            'md': size === 'medium',
            'lg': size === 'large'
        }"
        [style.top.px]="top"
        [style.left.px]="left"
        [style.transition]="(transitionEnabled ? '0.15s opacity' : '')"
        [style.opacity]="opacity"
        [style.display]="'block'"
        [class.in]="isIn"
        role="popover">
            <div [hidden]="!closeOnMouseOutside" class="virtual-area"></div>
            <div class="arrow"></div>
            <div class="popover-header" [hidden]="!title">{{ title }}</div>
            <div class="popover-body">
                <ng-content></ng-content>
                {{ content }}
            </div>
    </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }]; }, { placement: [{
            type: Input
        }], animation: [{
            type: Input
        }], closeOnClickOutside: [{
            type: Input
        }], closeOnMouseOutside: [{
            type: Input
        }], size: [{
            type: Input
        }], content: [{
            type: Input
        }], title: [{
            type: Input
        }], parentClass: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], popoverDiv: [{
            type: ViewChild,
            args: ['popoverDiv']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@group Basic Toolkit
 * \@component Popover Directive
 */
class PopoverDirective {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    /**
     * @param {?} viewContainerRef
     * @param {?} cdr
     * @param {?} resolver
     * @param {?} appRef
     * @param {?} injector
     */
    constructor(viewContainerRef, cdr, resolver, appRef, injector) {
        this.viewContainerRef = viewContainerRef;
        this.cdr = cdr;
        this.resolver = resolver;
        this.appRef = appRef;
        this.injector = injector;
        // -------------------------------------------------------------------------
        // Properties
        // -------------------------------------------------------------------------
        this.popoverContentComponent = PopoverContentComponent;
        this.popoverOnHover = true;
        this.popoverDismissTimeout = 0;
        this.onShown = new EventEmitter();
        this.onHidden = new EventEmitter();
    }
    // -------------------------------------------------------------------------
    // Event listeners
    // -------------------------------------------------------------------------
    /**
     * @param {?} evt
     * @return {?}
     */
    showOrHideOnClick(evt) {
        if (this.popoverOnHover) {
            return;
        }
        if (this.popoverDisabled) {
            return;
        }
        evt.stopImmediatePropagation();
        this.toggle();
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    showOrHideOnTouch(evt) {
        evt.stopImmediatePropagation();
        if (!this.popoverOnHover) {
            return;
        }
        if (this.popoverDisabled) {
            return;
        }
        this.toggle();
    }
    /**
     * @return {?}
     */
    showOnHover() {
        if (!this.popoverOnHover) {
            return;
        }
        if (this.popoverDisabled) {
            return;
        }
        this.show();
    }
    /**
     * @return {?}
     */
    hideOnHover() {
        if (this.popoverCloseOnMouseOutside) {
            return; // don't do anything since we do not control this
        }
        if (!this.popoverOnHover) {
            return;
        }
        if (this.popoverDisabled) {
            return;
        }
        this.hide();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['popoverDisabled']) {
            if (changes['popoverDisabled'].currentValue) {
                this.hide();
            }
        }
    }
    /**
     * @protected
     * @param {?} component
     * @return {?}
     */
    createComponent(component) {
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(component);
        // Create a component reference from the component
        /** @type {?} */
        const componentRef = this.appendToBody
            ? factory.create(this.injector)
            : this.viewContainerRef.createComponent(factory);
        if (this.appendToBody) {
            // Attach component to the appRef so that it's inside the ng component tree
            this.appRef.attachView(componentRef.hostView);
            // Get DOM element from component
            /** @type {?} */
            const domElem = (/** @type {?} */ (((/** @type {?} */ (componentRef.hostView)))
                .rootNodes[0]));
            // Append DOM element to the body
            document.body.appendChild(domElem);
        }
        return componentRef;
    }
    /**
     * @protected
     * @param {?} componentRef
     * @return {?}
     */
    removeComponent(componentRef) {
        if (this.popover) {
            if (this.appendToBody) {
                this.appRef.detachView(componentRef.hostView);
            }
            componentRef.destroy();
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * @return {?}
     */
    toggle() {
        if (!this.visible) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    show() {
        if (this.visible) {
            return;
        }
        this.visible = true;
        if (typeof this.content === 'string') {
            if (!this.visible) {
                return;
            }
            this.popover = this.createComponent(this.popoverContentComponent);
            /** @type {?} */
            const popover = (/** @type {?} */ (this.popover.instance));
            popover.popover = this;
            popover.content = (/** @type {?} */ (this.content));
            if (this.popoverPlacement !== undefined) {
                popover.placement = this.popoverPlacement;
            }
            if (this.popoverAnimation !== undefined) {
                popover.animation = this.popoverAnimation;
            }
            if (this.popoverTitle !== undefined) {
                popover.title = this.popoverTitle;
            }
            if (this.popoverCloseOnClickOutside !== undefined) {
                popover.closeOnClickOutside = this.popoverCloseOnClickOutside;
            }
            if (this.popoverCloseOnMouseOutside !== undefined) {
                popover.closeOnMouseOutside = this.popoverCloseOnMouseOutside;
            }
            if (this.popoverSize) {
                popover.size = this.popoverSize;
            }
            popover.appendToBody = this.appendToBody;
            popover.onCloseFromOutside.subscribe((/**
             * @return {?}
             */
            () => this.hide()));
            // if dismissTimeout option is set, then this popover will be dismissed in dismissTimeout time
            if (this.popoverDismissTimeout > 0) {
                setTimeout((/**
                 * @return {?}
                 */
                () => this.hide()), this.popoverDismissTimeout);
            }
        }
        else {
            /** @type {?} */
            const popover = (/** @type {?} */ (this.content));
            popover.popover = this;
            if (this.popoverPlacement !== undefined) {
                popover.placement = this.popoverPlacement;
            }
            if (this.popoverAnimation !== undefined) {
                popover.animation = this.popoverAnimation;
            }
            if (this.popoverTitle !== undefined) {
                popover.title = this.popoverTitle;
            }
            if (this.popoverCloseOnClickOutside !== undefined) {
                popover.closeOnClickOutside = this.popoverCloseOnClickOutside;
            }
            if (this.popoverCloseOnMouseOutside !== undefined) {
                popover.closeOnMouseOutside = this.popoverCloseOnMouseOutside;
            }
            if (this.popoverSize) {
                popover.size = this.popoverSize;
            }
            popover.appendToBody = this.appendToBody;
            popover.onCloseFromOutside.subscribe((/**
             * @return {?}
             */
            () => this.hide()));
            // if dismissTimeout option is set, then this popover will be dismissed in dismissTimeout time
            if (this.popoverDismissTimeout > 0) {
                setTimeout((/**
                 * @return {?}
                 */
                () => this.hide()), this.popoverDismissTimeout);
            }
            popover.show();
        }
        this.cdr.detectChanges();
        this.onShown.emit(this);
    }
    /**
     * @return {?}
     */
    hide() {
        if (!this.visible) {
            return;
        }
        this.visible = false;
        this.removeComponent(this.popover);
        if (this.content instanceof PopoverContentComponent) {
            ((/** @type {?} */ (this.content))).hideFromPopover();
        }
        this.cdr.detectChanges();
        this.onHidden.emit(this);
    }
    /**
     * @return {?}
     */
    getElement() {
        return this.viewContainerRef.element.nativeElement;
    }
}
PopoverDirective.ɵfac = function PopoverDirective_Factory(t) { return new (t || PopoverDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
PopoverDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PopoverDirective, selectors: [["", "popover", ""]], hostBindings: function PopoverDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PopoverDirective_click_HostBindingHandler($event) { return ctx.showOrHideOnClick($event); })("touchend", function PopoverDirective_touchend_HostBindingHandler($event) { return ctx.showOrHideOnTouch($event); })("focusin", function PopoverDirective_focusin_HostBindingHandler() { return ctx.showOnHover(); })("mouseenter", function PopoverDirective_mouseenter_HostBindingHandler() { return ctx.showOnHover(); })("focusout", function PopoverDirective_focusout_HostBindingHandler() { return ctx.hideOnHover(); })("mouseleave", function PopoverDirective_mouseleave_HostBindingHandler() { return ctx.hideOnHover(); });
    } }, inputs: { popoverOnHover: "popoverOnHover", popoverDismissTimeout: "popoverDismissTimeout", content: ["popover", "content"], popoverSize: "popoverSize", popoverDisabled: "popoverDisabled", popoverAnimation: "popoverAnimation", popoverPlacement: "popoverPlacement", popoverTitle: "popoverTitle", popoverCloseOnClickOutside: "popoverCloseOnClickOutside", popoverCloseOnMouseOutside: "popoverCloseOnMouseOutside", appendToBody: "appendToBody" }, outputs: { onShown: "onShown", onHidden: "onHidden" }, exportAs: ["popover"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
PopoverDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector }
];
PopoverDirective.propDecorators = {
    content: [{ type: Input, args: ['popover',] }],
    popoverSize: [{ type: Input }],
    popoverDisabled: [{ type: Input }],
    popoverAnimation: [{ type: Input }],
    popoverPlacement: [{ type: Input }],
    popoverTitle: [{ type: Input }],
    popoverOnHover: [{ type: Input }],
    popoverCloseOnClickOutside: [{ type: Input }],
    popoverCloseOnMouseOutside: [{ type: Input }],
    popoverDismissTimeout: [{ type: Input }],
    appendToBody: [{ type: Input }],
    onShown: [{ type: Output }],
    onHidden: [{ type: Output }],
    showOrHideOnClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    showOrHideOnTouch: [{ type: HostListener, args: ['touchend', ['$event'],] }],
    showOnHover: [{ type: HostListener, args: ['focusin',] }, { type: HostListener, args: ['mouseenter',] }],
    hideOnHover: [{ type: HostListener, args: ['focusout',] }, { type: HostListener, args: ['mouseleave',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopoverDirective, [{
        type: Directive,
        args: [{
                selector: '[popover]',
                exportAs: 'popover'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.Injector }]; }, { popoverOnHover: [{
            type: Input
        }], popoverDismissTimeout: [{
            type: Input
        }], onShown: [{
            type: Output
        }], onHidden: [{
            type: Output
        }], 
    // -------------------------------------------------------------------------
    // Event listeners
    // -------------------------------------------------------------------------
    /**
     * @param {?} evt
     * @return {?}
     */
    showOrHideOnClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /**
     * @param {?} evt
     * @return {?}
     */
    showOrHideOnTouch: [{
            type: HostListener,
            args: ['touchend', ['$event']]
        }], 
    /**
     * @return {?}
     */
    showOnHover: [{
            type: HostListener,
            args: ['focusin']
        }, {
            type: HostListener,
            args: ['mouseenter']
        }], 
    /**
     * @return {?}
     */
    hideOnHover: [{
            type: HostListener,
            args: ['focusout']
        }, {
            type: HostListener,
            args: ['mouseleave']
        }], content: [{
            type: Input,
            args: ['popover']
        }], popoverSize: [{
            type: Input
        }], popoverDisabled: [{
            type: Input
        }], popoverAnimation: [{
            type: Input
        }], popoverPlacement: [{
            type: Input
        }], popoverTitle: [{
            type: Input
        }], popoverCloseOnClickOutside: [{
            type: Input
        }], popoverCloseOnMouseOutside: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverModule {
}
PopoverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PopoverModule });
PopoverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PopoverModule_Factory(t) { return new (t || PopoverModule)(); }, imports: [[
            CommonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PopoverModule, { declarations: function () { return [PopoverDirective, PopoverContentComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [PopoverContentComponent, PopoverDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopoverModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    PopoverDirective,
                    PopoverContentComponent
                ],
                imports: [
                    CommonModule,
                ],
                exports: [
                    PopoverContentComponent,
                    PopoverDirective
                ],
                entryComponents: [
                    PopoverContentComponent
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { PopoverContentComponent, PopoverDirective, PopoverModule, PopoverPlacement };

//# sourceMappingURL=ngx-smart-popover-px.js.map